generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
	 directUrl = env("DATABASE_URL_UNPOOLED")
}

// NextAuth.js models
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id            String       @id @default(cuid())
  name          String?
  email         String?      @unique
  emailVerified DateTime?
  image         String?
  phoneNumber   String?      @unique

  // UI preferences
  theme         String       @default("storm-cyan")
  
  accounts      Account[]
  sessions      Session[]
  budgetPlans   BudgetPlan[]
  onboardingProfile UserOnboardingProfile?
  mobileAuthSessions MobileAuthSession[]
  webPushSubscriptions WebPushSubscription[]
  mobilePushTokens MobilePushToken[]
  receipts       Receipt[]
  
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
}

enum OnboardingGoal {
  improve_savings
  manage_debts
  track_spending
  build_budget
}

enum OnboardingStatus {
  started
  completed
}

model UserOnboardingProfile {
  id                 String           @id @default(cuid())
  userId             String           @unique
  user               User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  status             OnboardingStatus @default(started)
  completedAt        DateTime?

  mainGoal           OnboardingGoal?
  mainGoals          OnboardingGoal[] @default([])
  occupation         String?
  occupationOther    String?
  monthlySalary      Decimal?         @db.Decimal(12, 2)

  expenseOneName     String?
  expenseOneAmount   Decimal?         @db.Decimal(12, 2)
  expenseTwoName     String?
  expenseTwoAmount   Decimal?         @db.Decimal(12, 2)

  hasAllowance       Boolean?
  allowanceAmount    Decimal?         @db.Decimal(12, 2)

  hasDebtsToManage   Boolean?
  debtAmount         Decimal?         @db.Decimal(12, 2)
  debtNotes          String?

  generatedPlanId    String?

  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt

  @@index([status])
}

model MobileAuthSession {
  id         String   @id @default(cuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt  DateTime
  revokedAt  DateTime?
  lastSeenAt DateTime @default(now())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([userId])
  @@index([expiresAt])
  @@index([userId, revokedAt, expiresAt])
}

model WebPushSubscription {
  id        String   @id @default(cuid())
  userId    String
  endpoint  String   @unique
  p256dh    String
  auth      String
  userAgent String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model MobilePushToken {
  id         String   @id @default(cuid())
  userId     String
  token      String   @unique
  platform   String?
  deviceId   String?
  lastSeenAt DateTime @default(now())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// Budget Plan - Each user can have multiple budget plans
model BudgetPlan {
  id          String   @id @default(cuid())
  name        String   @default("My Budget")
  kind        BudgetPlanKind @default(personal)
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Holiday/Carnival metadata
  eventDate                     DateTime?
  includePostEventIncome         Boolean        @default(false)

  // Tracks one-time default category seeding/backfills.
  categorySeedVersion          Int            @default(0)
  
  // Budget plan settings
  payDate                       Int            @default(27)
  monthlyAllowance              Decimal        @default(0) @db.Decimal(12, 2)
  savingsBalance                Decimal        @default(0) @db.Decimal(12, 2)
  emergencyBalance              Decimal        @default(0) @db.Decimal(12, 2)
  investmentBalance             Decimal        @default(0) @db.Decimal(12, 2)
  monthlySavingsContribution    Decimal        @default(0) @db.Decimal(12, 2)
  monthlyEmergencyContribution  Decimal        @default(0) @db.Decimal(12, 2)
  monthlyInvestmentContribution Decimal        @default(0) @db.Decimal(12, 2)
  budgetStrategy                BudgetStrategy @default(payYourselfFirst)

  // Planning horizon
  budgetHorizonYears            Int            @default(10)

  // Income yearly add defaults
  incomeDistributeFullYearDefault Boolean      @default(false)
  incomeDistributeHorizonDefault  Boolean      @default(false)

  // Dashboard preferences
  homepageGoalIds               String[]       @default([])
  
  // Locale settings
  country                       String         @default("GB")
  language                      String         @default("en")
  currency                      String         @default("GBP")
  
  // Relations
  categories Category[]
  expenses   Expense[]
  income     Income[]
  debts      Debt[]
  goals      Goal[]
  sacrificeGoalLinks SacrificeGoalLink[]
  sacrificeTransferConfirmations SacrificeTransferConfirmation[]
  monthlyAllocations MonthlyAllocation[]
  allocationDefinitions AllocationDefinition[]
  monthlyAllocationItems MonthlyAllocationItem[]
  receipts   Receipt[]
  
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  
  @@index([userId])
  @@index([userId, kind])
}

model AllocationDefinition {
  id            String   @id @default(cuid())
  name          String
  defaultAmount Decimal  @default(0) @db.Decimal(12, 2)
  sortOrder     Int      @default(0)
  isArchived    Boolean  @default(false)

  budgetPlanId  String
  budgetPlan    BudgetPlan @relation(fields: [budgetPlanId], references: [id], onDelete: Cascade)

  monthlyItems  MonthlyAllocationItem[]

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([budgetPlanId, name])
  @@index([budgetPlanId, isArchived, sortOrder])
}

model MonthlyAllocationItem {
  id            String   @id @default(cuid())
  year          Int
  month         Int
  amount        Decimal  @db.Decimal(12, 2)

  allocationId  String
  allocation    AllocationDefinition @relation(fields: [allocationId], references: [id], onDelete: Cascade)

  budgetPlanId  String
  budgetPlan    BudgetPlan @relation(fields: [budgetPlanId], references: [id], onDelete: Cascade)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([allocationId, year, month])
  @@index([budgetPlanId, year, month])
}

model MonthlyAllocation {
  id String @id @default(cuid())

  year  Int
  month Int

  monthlyAllowance              Decimal @default(0) @db.Decimal(12, 2)
  monthlySavingsContribution    Decimal @default(0) @db.Decimal(12, 2)
  monthlyEmergencyContribution  Decimal @default(0) @db.Decimal(12, 2)
  monthlyInvestmentContribution Decimal @default(0) @db.Decimal(12, 2)

  budgetPlanId String
  budgetPlan   BudgetPlan @relation(fields: [budgetPlanId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([budgetPlanId, year, month])
  @@index([budgetPlanId])
}

enum BudgetPlanKind {
  personal
  holiday
  carnival
}

model Category {
  id           String     @id @default(cuid())
  name         String
  icon         String?
  color        String?
  featured     Boolean    @default(false)
  
  budgetPlanId String
  budgetPlan   BudgetPlan @relation(fields: [budgetPlanId], references: [id], onDelete: Cascade)

  expenses     Expense[]
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  @@unique([budgetPlanId, name])
  @@index([budgetPlanId])
}

model CategoryTemplate {
  id        String   @id @default(cuid())
  // "base" applies to all plans; otherwise match BudgetPlan.kind values.
  kindKey   String
  name      String
  icon      String?
  color     String?
  featured  Boolean  @default(false)
  sortOrder Int      @default(0)
  isActive  Boolean  @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([kindKey, name])
  @@index([kindKey, isActive, sortOrder])
}

model Expense {
  id           String     @id @default(cuid())
  name         String
  merchantDomain String?
  logoUrl      String?
  logoSource   String?
  amount       Decimal    @db.Decimal(12, 2)
  paid         Boolean    @default(false)
  paidAmount   Decimal    @default(0) @db.Decimal(12, 2)
  // If true, this record represents an allocation/envelope amount, not a bill.
  // It must never generate an expense-backed debt.
  isAllocation  Boolean    @default(false)
  // If true, this is a direct debit / standing order — collected automatically.
  isDirectDebit Boolean    @default(false)
  month         Int
  year         Int
  dueDate      DateTime?  // Full due date, defaults to payDate day of the current/next month if not set

  budgetPlanId String
  budgetPlan   BudgetPlan @relation(fields: [budgetPlanId], references: [id], onDelete: Cascade)
  
  categoryId   String?
  category     Category?  @relation(fields: [categoryId], references: [id], onDelete: SetNull)

	payments     ExpensePayment[]

  // Timestamp of the most recent manual or partial payment applied to this expense.
  // null = no payment has been recorded yet.
  lastPaymentAt DateTime?

  // Intended payment source — stored at creation time and reused when the
  // expense is later marked as paid so the correct balance can be deducted.
  paymentSource ExpensePaymentSource? @default(income)
  // When paymentSource = credit_card, the specific card (Debt) to charge.
  cardDebtId    String?
  cardDebt      Debt?   @relation("ExpenseCard", fields: [cardDebtId], references: [id], onDelete: SetNull)

  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  @@index([budgetPlanId, month, year])
  @@index([categoryId])
  @@index([budgetPlanId, isAllocation])
}

enum ExpensePaymentSource {
  income
  savings
  credit_card
  emergency
  extra_untracked
}

model ExpensePayment {
  id        String               @id @default(cuid())
  expenseId String
  expense   Expense              @relation(fields: [expenseId], references: [id], onDelete: Cascade)
  amount    Decimal              @db.Decimal(12, 2)
  source    ExpensePaymentSource
  debtId    String?
  debt      Debt?                @relation(fields: [debtId], references: [id], onDelete: SetNull)
  paidAt    DateTime
  createdAt DateTime             @default(now())
  updatedAt DateTime             @updatedAt

  @@index([expenseId])
  @@index([paidAt])
  @@index([source])
  @@index([debtId])
}

model Income {
  id           String     @id @default(cuid())
  name         String
  amount       Decimal    @db.Decimal(12, 2)
  month        Int
  year         Int
  
  budgetPlanId String
  budgetPlan   BudgetPlan @relation(fields: [budgetPlanId], references: [id], onDelete: Cascade)
  
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  @@index([budgetPlanId, month, year])
}

enum DebtType {
  credit_card
  store_card
  loan
  mortgage
  hire_purchase
  other
}

model Debt {
  id                   String         @id @default(cuid())
  name                 String
  type                 DebtType
  creditLimit          Decimal?       @db.Decimal(12, 2)
  dueDay               Int?
  // Full due date (calendar date). Used for missed-payment logic (overdue + 5 days).
  dueDate              DateTime?
  // Used to ensure missed-payment accrual is applied at most once per month.
  // Stored as YYYY-MM (UTC).
  lastAccrualMonth      String?
  initialBalance       Decimal        @db.Decimal(12, 2)
  currentBalance       Decimal        @db.Decimal(12, 2)
  amount               Decimal        @db.Decimal(12, 2)
  paid                 Boolean        @default(false)
  paidAmount           Decimal        @default(0) @db.Decimal(12, 2)
  defaultPaymentSource DebtPaymentSource @default(income)
  defaultPaymentCardDebtId String?
  defaultPaymentCard   Debt?          @relation("DebtDefaultPaymentCard", fields: [defaultPaymentCardDebtId], references: [id], onDelete: SetNull)
  debtsPaidByThisCard  Debt[]         @relation("DebtDefaultPaymentCard")
  monthlyMinimum       Decimal?       @db.Decimal(12, 2)
  interestRate         Decimal?       @db.Decimal(5, 2)
  installmentMonths    Int?
  
  budgetPlanId         String
  budgetPlan           BudgetPlan     @relation(fields: [budgetPlanId], references: [id], onDelete: Cascade)
  
  // For debts created from expenses
  sourceType           String?
  sourceExpenseId      String?
  sourceMonthKey       String?
  sourceCategoryId     String?
  sourceCategoryName   String?
  sourceExpenseName    String?
  
  payments             DebtPayment[]
  debtPaymentsAsCard   DebtPayment[]  @relation("DebtPaymentCard")
  expensePayments      ExpensePayment[]
  expensesChargedToCard Expense[]     @relation("ExpenseCard")
  createdAt            DateTime       @default(now())
  updatedAt            DateTime       @updatedAt
  
  @@index([budgetPlanId])
}

model DebtPayment {
  id          String   @id @default(cuid())
  debtId      String
  debt        Debt     @relation(fields: [debtId], references: [id], onDelete: Cascade)
  amount      Decimal  @db.Decimal(12, 2)
  paidAt      DateTime
  year        Int
  month       Int
  source      DebtPaymentSource @default(income)
  cardDebtId  String?
  cardDebt    Debt?    @relation("DebtPaymentCard", fields: [cardDebtId], references: [id], onDelete: SetNull)
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([debtId])
  @@index([paidAt])
  @@index([debtId, year, month])
  @@index([year, month, source])
  @@index([cardDebtId])
}

enum DebtPaymentSource {
  income
  extra_funds
  credit_card
}

enum GoalType {
  yearly
  long_term
  short_term
}

enum GoalCategory {
  debt
  emergency
  savings
  investment
  other
}

model Goal {
  id            String       @id @default(cuid())
  title         String
  type          GoalType
  category      GoalCategory
  description   String?
  targetAmount  Decimal?     @db.Decimal(12, 2)
  currentAmount Decimal?     @default(0) @db.Decimal(12, 2)
  targetYear    Int?
  
  budgetPlanId  String
  budgetPlan    BudgetPlan   @relation(fields: [budgetPlanId], references: [id], onDelete: Cascade)
  sacrificeGoalLinks SacrificeGoalLink[]
  sacrificeTransferConfirmations SacrificeTransferConfirmation[]
  
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt
  
  @@index([budgetPlanId])
}

model SacrificeGoalLink {
  id          String   @id @default(cuid())
  targetKey   String

  budgetPlanId String
  budgetPlan   BudgetPlan @relation(fields: [budgetPlanId], references: [id], onDelete: Cascade)

  goalId      String
  goal        Goal     @relation(fields: [goalId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([budgetPlanId, targetKey])
  @@index([goalId])
  @@index([budgetPlanId])
}

model SacrificeTransferConfirmation {
  id          String   @id @default(cuid())
  year        Int
  month       Int
  targetKey   String
  amount      Decimal  @db.Decimal(12, 2)
  confirmedAt DateTime @default(now())

  budgetPlanId String
  budgetPlan   BudgetPlan @relation(fields: [budgetPlanId], references: [id], onDelete: Cascade)

  goalId      String
  goal        Goal     @relation(fields: [goalId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([budgetPlanId, year, month, targetKey])
  @@index([goalId])
  @@index([budgetPlanId, year, month])
}

enum BudgetStrategy {
  payYourselfFirst
  zeroBased
  fiftyThirtyTwenty
}

// Removed Settings model - now part of BudgetPlan

// ── Receipt scanning ──────────────────────────────────────────────

enum ReceiptStatus {
  pending
  confirmed
  failed
}

model Receipt {
  id           String        @id @default(cuid())

  userId       String
  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  budgetPlanId String?
  budgetPlan   BudgetPlan?   @relation(fields: [budgetPlanId], references: [id], onDelete: SetNull)

  // AI-parsed fields (editable by user before confirming)
  merchant     String?
  amount       Decimal?      @db.Decimal(12, 2)
  currency     String?       @default("GBP")
  expenseDate  DateTime?
  suggestedCategory String?

  // Full raw JSON from AI
  rawJson      Json?

  // Lifecycle
  status       ReceiptStatus @default(pending)

  // ID of the Expense record created when user confirms
  expenseId    String?       @unique

  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  @@index([userId])
  @@index([budgetPlanId])
  @@index([userId, status])
}

