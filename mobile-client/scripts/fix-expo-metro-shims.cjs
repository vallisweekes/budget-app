const fs = require('fs');
const path = require('path');

const projectRoot = path.resolve(__dirname, '..');
const expoMetroRoot = path.join(projectRoot, 'node_modules', '@expo', 'metro');
const expoMetroPackageJsonPath = path.join(expoMetroRoot, 'package.json');

function fileExists(filePath) {
  try {
    fs.accessSync(filePath, fs.constants.F_OK);
    return true;
  } catch {
    return false;
  }
}

function ensureFile(filePath, content) {
  fs.mkdirSync(path.dirname(filePath), { recursive: true });
  if (!fileExists(filePath)) {
    fs.writeFileSync(filePath, content, 'utf8');
    return true;
  }

  // If we've previously generated this file, allow updating it when the generator changes.
  try {
    const existing = fs.readFileSync(filePath, 'utf8');
    if (existing.includes('Auto-generated by scripts/fix-expo-metro-shims.cjs') && existing !== content) {
      fs.writeFileSync(filePath, content, 'utf8');
      return true;
    }
  } catch {
    // ignore
  }

  return false;
}

function listJsFilesRecursive(rootDir) {
  /** @type {string[]} */
  const results = [];

  /** @type {string[]} */
  const stack = [rootDir];
  while (stack.length) {
    const dir = stack.pop();
    if (!dir) continue;

    let entries;
    try {
      entries = fs.readdirSync(dir, { withFileTypes: true });
    } catch {
      continue;
    }

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      if (entry.isDirectory()) {
        stack.push(fullPath);
      } else if (entry.isFile() && entry.name.endsWith('.js')) {
        results.push(fullPath);
      }
    }
  }

  return results;
}

function countJsFilesRecursive(rootDir) {
  try {
    return listJsFilesRecursive(rootDir).length;
  } catch {
    return 0;
  }
}

function createForwarder(destFile, requireTarget) {
  const shimContent =
    `// Auto-generated by scripts/fix-expo-metro-shims.cjs\n` +
    `// Repairs missing files in @expo/metro by forwarding to the real metro-* packages.\n` +
    `\n` +
    `const mod = require(${JSON.stringify(requireTarget)});\n` +
    `module.exports = mod;\n` +
    `module.exports.default = mod && mod.default ? mod.default : mod;\n`;

  return ensureFile(destFile, shimContent);
}

function createPackageFileForwarder(destFile, packageName, fileRelFromPackageRoot) {
  const shimContent =
    `// Auto-generated by scripts/fix-expo-metro-shims.cjs\n` +
    `// Repairs missing files in @expo/metro by forwarding to the real metro-* packages.\n` +
    `// This file is required via deep imports like \"@expo/metro/${packageName}/...\".\n` +
    `//\n` +
    `// NOTE: We cannot require deep paths like \"${packageName}/src/...\" because Metro packages\n` +
    `// use \"exports\" which blocks those subpaths in Node 20+.\n` +
    `\n` +
    `const path = require('path');\n` +
    `const packageJsonPath = require.resolve(${JSON.stringify(`${packageName}/package.json`)});\n` +
    `const packageRoot = path.dirname(packageJsonPath);\n` +
    `const mod = require(path.join(packageRoot, ${JSON.stringify(fileRelFromPackageRoot)}));\n` +
    `module.exports = mod;\n` +
    `module.exports.default = mod && mod.default ? mod.default : mod;\n`;

  return ensureFile(destFile, shimContent);
}

function createRuntimeExportForwarder(destFile, requireTarget) {
  const shimContent =
    `// Auto-generated by scripts/fix-expo-metro-shims.cjs\n` +
    `// RN-safe forwarder (no Node builtins).\n` +
    `\n` +
    `const mod = require(${JSON.stringify(requireTarget)});\n` +
    `module.exports = mod;\n` +
    `module.exports.default = mod && mod.default ? mod.default : mod;\n`;

  return ensureFile(destFile, shimContent);
}

function mirrorMetroSubpackage({
  expoMetroRoot,
  projectRoot,
  subpackage,
  minExistingJsFiles,
}) {
  const targetDir = path.join(expoMetroRoot, subpackage);
  const sourceDir = path.join(projectRoot, 'node_modules', subpackage, 'src');

  // Special-case: metro-runtime is required by app JS (e.g. HMRClient). Any shim we
  // create here must be RN-safe and must NOT depend on Node builtins like `path`.
  if (subpackage === 'metro-runtime') {
    const runtimePackageJsonPath = path.join(projectRoot, 'node_modules', 'metro-runtime', 'package.json');
    if (!fileExists(runtimePackageJsonPath)) {
      return 0;
    }

    let createdCount = 0;
    let runtimePkg;
    try {
      runtimePkg = JSON.parse(fs.readFileSync(runtimePackageJsonPath, 'utf8'));
    } catch {
      return 0;
    }

    const exportsField = runtimePkg.exports;
    if (!exportsField || typeof exportsField !== 'object') {
      return 0;
    }

    for (const exportKey of Object.keys(exportsField)) {
      if (exportKey === './package.json') continue;
      if (!exportKey.startsWith('./')) continue;

      // Example exportKey: "./modules/HMRClient" -> require("metro-runtime/modules/HMRClient")
      const rel = exportKey.slice(2);
      if (!rel) continue;

      const destFile = path.join(targetDir, ...rel.split('/')) + '.js';
      const requireTarget = `metro-runtime/${rel}`;
      if (createRuntimeExportForwarder(destFile, requireTarget)) {
        createdCount += 1;
      }
    }

    return createdCount;
  }

  if (!fileExists(sourceDir)) {
    return 0;
  }

  // Always attempt to mirror/update the forwarders.
  // This keeps installs stable even if previously generated shims were incomplete or incorrect.
  // (Writes are deduped by ensureFile.)
  void minExistingJsFiles;

  let createdCount = 0;
  const sourceFiles = listJsFilesRecursive(sourceDir);
  for (const absoluteSourceFile of sourceFiles) {
    const rel = path.relative(sourceDir, absoluteSourceFile).split(path.sep).join('/');
    const destFile = path.join(targetDir, ...rel.split('/'));
    const fileRelFromPackageRoot = `src/${rel}`;
    if (createPackageFileForwarder(destFile, subpackage, fileRelFromPackageRoot)) {
      createdCount += 1;
    }
  }

  return createdCount;
}

function main() {
  if (!fileExists(expoMetroPackageJsonPath)) {
    return;
  }

  const pkg = JSON.parse(fs.readFileSync(expoMetroPackageJsonPath, 'utf8'));
  const exportsField = pkg.exports;
  if (!exportsField || typeof exportsField !== 'object') {
    return;
  }

  let createdCount = 0;

  for (const [exportKey, exportTarget] of Object.entries(exportsField)) {
    if (exportKey === './package.json') continue;
    if (exportKey.includes('*')) continue;
    if (typeof exportTarget !== 'string') continue;

    // We only generate shims for targets that point at an index.js under a folder,
    // e.g. "./metro-core": "./metro-core/index.js".
    if (!exportTarget.endsWith('/index.js')) continue;

    const subpath = exportKey.startsWith('./') ? exportKey.slice(2) : exportKey;
    if (!subpath) continue;

    const shimPath = path.join(expoMetroRoot, ...subpath.split('/'), 'index.js');

    // Mirror the same subpath into the underlying metro packages.
    // Examples:
    // - "metro-core" -> require("metro-core")
    // - "metro-config/defaults" -> require("metro-config/defaults")
    const requireTarget = subpath;

    if (createForwarder(shimPath, requireTarget)) {
      createdCount += 1;
    }
  }

  // Some installs of @expo/metro include the big "metro" folder but omit other subpackages like
  // "metro-cache" or "metro-core", while Expo CLI deep-imports into them (e.g.
  // @expo/metro/metro-cache/stores/FileStore). When that happens, create forwarder shims for all
  // JS files under the real metro-* packages' src trees.
  const subpackagesToMirror = Object.keys(pkg.dependencies || {})
    .filter((name) => name.startsWith('metro-'))
    // @expo/metro/metro is shipped with lots of real files already; mirroring it would be huge.
    .filter((name) => name !== 'metro');

  for (const subpackage of subpackagesToMirror) {
    createdCount += mirrorMetroSubpackage({
      expoMetroRoot,
      projectRoot,
      subpackage,
      // If the folder is basically empty (or just has our index.js shim), mirror it.
      minExistingJsFiles: 3,
    });
  }

  if (createdCount > 0) {
    // eslint-disable-next-line no-console
    console.log(`[fix-expo-metro-shims] Created ${createdCount} shim file(s) in @expo/metro`);
  }
}

try {
  main();
} catch (error) {
  // Don't fail installs for this best-effort repair.
  // eslint-disable-next-line no-console
  console.warn('[fix-expo-metro-shims] Failed:', error && error.message ? error.message : error);
}
